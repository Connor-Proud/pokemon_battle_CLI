// lib.rs calculates damage based on pokemon, move, and csv data
// compiled as a shared library for use in Python via ctypes
use std::ffi::{CStr};use std::os::raw::c_char;use std::fs::File;use std::error::Error;use std::collections::HashMap;use csv::StringRecord;use rand::Rng;

fn capitalize_python_style(s: &str) -> String {let mut c = s.chars();match c.next() {None => String::new(),Some(first) => first.to_uppercase().collect::<String>() + c.as_str().to_lowercase().as_str(),}}

fn read_pokemon_csv(path: &str) -> Result<Vec<StringRecord>, Box<dyn Error>> {let mut rdr = csv::Reader::from_path(path)?;let mut rows = Vec::new();for rec in rdr.records() {rows.push(rec?);}Ok(rows)}

fn find_pokemon_by_name(rows: &[StringRecord], headers: &csv::StringRecord, name_col: &str, name: &str) -> Option<StringRecord> {let idx = headers.iter().position(|h| h == name_col)?;for r in rows {if let Some(val) = r.get(idx) {if val == name {return Some(r.clone());}}}None}

fn get_field<'a>(record: &'a StringRecord, headers: &csv::StringRecord, key: &str) -> Option<&'a str> {headers.iter().position(|h| h == key).and_then(|i| record.get(i))}

fn parse_f64_field(record: &StringRecord, headers: &csv::StringRecord, key: &str) -> Option<f64> {get_field(record, headers, key).and_then(|s| {let trimmed = s.trim();if trimmed.is_empty() { None } else { trimmed.parse::<f64>().ok() }})}

/// Convert C strings and return damage as i32
/// Returns:
///  >=0 : damage dealt
///  -1  : "miss"
///  -2  : error (missing CSV entry etc)
#[no_mangle]
pub extern "C" fn dmg_calc(instigator: *const c_char, victim: *const c_char, move_name: *const c_char) -> i32 {let instigator = unsafe {if instigator.is_null() { return -2; }match CStr::from_ptr(instigator).to_str() {Ok(s) => s.to_string(),Err(_) => return -2,}};let victim = unsafe {if victim.is_null() { return -2; }match CStr::from_ptr(victim).to_str() {Ok(s) => s.to_string(),Err(_) => return -2,}};let move_name = unsafe {if move_name.is_null() { return -2; }match CStr::from_ptr(move_name).to_str() {Ok(s) => s.to_string(),Err(_) => return -2,}};let instig = capitalize_python_style(&instigator);let victim_name = capitalize_python_style(&victim);let poke_path = "files/pokemon.csv";let moves_path = "files/moves.csv";let poke_file = match File::open(poke_path) {Ok(f) => f,Err(_) => return -2,};let mut poke_rdr = match csv::Reader::from_reader(poke_file) {rdr => rdr,};let poke_headers = poke_rdr.headers().map(|h| h.clone()).unwrap_or_else(|_| csv::StringRecord::new());let poke_rows: Vec<StringRecord> = poke_rdr.records().filter_map(|r| r.ok()).collect();let move_file = match File::open(moves_path) {Ok(f) => f,Err(_) => return -2,};let mut move_rdr = match csv::Reader::from_reader(move_file) {rdr => rdr,};let move_headers = move_rdr.headers().map(|h| h.clone()).unwrap_or_else(|_| csv::StringRecord::new());let move_rows: Vec<StringRecord> = move_rdr.records().filter_map(|r| r.ok()).collect();let move_idx = move_headers.iter().position(|h| h == "name");let power_idx = move_headers.iter().position(|h| h == "power");let type_idx = move_headers.iter().position(|h| h == "type");if move_idx.is_none() || power_idx.is_none() || type_idx.is_none() {return -2;}let move_idx = move_idx.unwrap();let power_idx = power_idx.unwrap();let type_idx = type_idx.unwrap();let mut found_move: Option<StringRecord> = None;for r in &move_rows {if let Some(n) = r.get(move_idx) {if n == move_name {found_move = Some(r.clone());break;}}}let move_rec = match found_move {Some(m) => m,None => return -2,};let instigator_pwr: f64 = match move_rec.get(power_idx).and_then(|s| s.trim().parse::<f64>().ok()) {Some(v) => v,None => 0.0,};let move_type = move_rec.get(type_idx).map(|s| s.to_lowercase()).unwrap_or_else(|| "".to_string());let inst_row = match find_pokemon_by_name(&poke_rows, &poke_headers, " Name", &instig) {Some(r) => r,None => return -2,};let vic_row = match find_pokemon_by_name(&poke_rows, &poke_headers, " Name", &victim_name) {Some(r) => r,None => return -2,};let effective_attack = parse_f64_field(&inst_row, &poke_headers, " Attack").unwrap_or(0.0);let victim_def = parse_f64_field(&vic_row, &poke_headers, " Defense").unwrap_or(1.0);let instigator_type_1 = get_field(&inst_row, &poke_headers, " Type1").map(|s| s.to_lowercase()).unwrap_or_else(|| "".to_string());let instigator_type_2_opt: Option<String> = get_field(&inst_row, &poke_headers, " Type2").and_then(|s| {if s.trim().is_empty() { None } else { Some(s.to_string()) }});let mut type_columns: HashMap<&str, &str> = HashMap::new();type_columns.insert("normal", " Normal_Dmg");type_columns.insert("fire", " Fire_Dmg");type_columns.insert("water", " Water_Dmg");type_columns.insert("electric", " Eletric_Dmg");type_columns.insert("grass", " Grass_Dmg");type_columns.insert("ice", " Ice_Dmg");type_columns.insert("fighting", " Fight_Dmg");type_columns.insert("poison", " Poison_Dmg");type_columns.insert("ground", " Ground_Dmg");type_columns.insert("flying", " Flying_Dmg");type_columns.insert("psychic", " Psychic_Dmg");type_columns.insert("bug", " Bug_Dmg");type_columns.insert("rock", " Rock_Dmg");type_columns.insert("ghost", " Ghost_Dmg");type_columns.insert("dragon", " Dragon_Dmg");let type_effectiveness = if let Some(col_name) = type_columns.get(move_type.as_str()) {parse_f64_field(&vic_row, &poke_headers, col_name).unwrap_or(1.0)} else {1.0};let mut same_type_attack_bonus = 1.0;if move_type == instigator_type_1 {same_type_attack_bonus = 1.5;} else if let Some(t2) = &instigator_type_2_opt {if move_type == t2.to_lowercase() {same_type_attack_bonus = 1.5;}}let mut rng = rand::thread_rng();let crit_rand = (rng.gen_range(0..=1000) as f64) / 10.0;let instigator_crit = if crit_rand < 4.7 { 2.0 } else { 1.0 };let instigator_level = 1.0;let base_damage = ((2.0 * instigator_level * instigator_crit) / 5.0 + 2.0)* instigator_pwr* effective_attack/ victim_def/ 50.0+ 2.0;let mut dmg_dealt = base_damage * same_type_attack_bonus * type_effectiveness;let rand_factor = rng.gen_range(217..=255) as f64 / 255.0;dmg_dealt = (dmg_dealt * rand_factor).floor();let dmg_i = dmg_dealt as i32;if dmg_i == 0 {-1} else {dmg_i}}

